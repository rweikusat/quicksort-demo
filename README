Quicksort Demo
==============
A while ago, I noticed that I had, because of years of non-use,
forgotten how this algorithm worked. I tried to look it up in a German
edition of Sedgewick's "Algorithms and Datastructures in C" which
deserves to be famous for the inadequacy of its explanations and the
incomprehensibility of its code examples and found it ... well
... incomprehensible. Next, I tried Wikipedia,  with no more
success. While I obviously have "The Art of Computer Programming"
here, I didn't try that for reasons anybody who knows the books will
understand. I then let he matter rest for a few months.

Some days ago, during an evening in the pub, my mind picked this up
again but instead of trying to just look it up somewhere, I set forth
to work it out in my head based on my general knowledge about how the
algorithm is supposed to work. This turned out be surprisingly easy
for something where such heights of incomprehensibility while trying to
explain it could be achieved. I wrote the demo program to test my theory
and also, to have a complete implementation actually suitable for
human digestion.

NB: This is an algorithmic demonstration *and* *not* an armour-plated
implementation supposed to be usable to deflect machine-gun fire of a
dedicated enemy. As such, it uses simple C types like int and unsigned
without regard for their necessarily limited sizes.


,----
| Original Idea
`----

The description below applies to the algorithm I originally came up
with. After having another look at both Knuth's and Sedgewick's texts,
I created a second version which is better in the sense that it
usually needs fewer comparisons and swaps for the same dataset, albeit
not "order-of-magnitude-style" better. This one is described below.


Basic Idea
----------
The basic idea behind quicksort is to pick a pivot element from the
array that's to be sorted. Neither the position of this element nor
its value matter for the algorithm although the ideal choice would be
to always pick the element in the middle. The array is then
partitioned into two subarrays, a left one which contains all elements
<= the pivot and a right one which contains all > than it. The
algorithm is then recursively applied to these two subfields.

The recursion terminates when the size of the subfield which is to be
sorted is either 0 or 1 (trivially sorted). A subfield of size 2 is
handled specially by comparing both elements, swapping them if
necessary, and terminating the recursion as well.


Invocation
----------
The qs function is invoked with three arguments: A pointer to the
complete field that's to be sorted, the index of the left-most element
of the subfield this invocation should handle ("l") and the index of the
right-most element of this subfield ("r").

NB: This means that the length of this subfield is r + 1 - l.


Choice of Pivot
---------------
This implementation choses the right-most element of the field as
pivot because this avoids dealing with the special case of having chosen
the largest number which would cause the partitioning loop described
below to terminate with left and right index pointing to the last
element of the array. If that's the pivot, no further action is
necessary. Otherwise, the pivot element would need to be swapped with
the last element.


Partitioning Loop
-----------------
The partitioning loop works as follows: First, record the original left
position ("ol") and the original right position ("or"). Starting from
the left ("l"), look for an element that's larger than the pivot. If
such an element is found, move leftward from the right ("r") until an
element not larger than the pivot is found or r collides with l. If
such an element was found, swap the elements at position r and l and
increase l. The outer loop terminates once l == r.

At this point, the subfield ol .. l - 1 contains all members <= the
pivot and the subfield l .. or all which are > than the pivot unless
the pivot was itself the largest element. For this special case, all
elements in the left subfield are <= the pivot and the right subfield
contains just the pivot.


,----
| Faster Algorithm
`----

This describes only the differences to the other algorithm.


Basic Idea
----------
The difference to the first alogrithm is that this one partitions the
input field in three subfields, a left one which contains all input
elements <= the pivot, the pivot itself and a right subfield
containing all elements > than it. This is accomplished by swapping
the pivot with the right-most element of the left subfield after
partitioning as that's the position the pivot must occupy in the fully
sorted field.


Choice of Pivot
---------------
In order to move the pivot to its final location in the sorted array
after the partioning loop terminated, the position of the pivot in the
partioned array must obviously be known. Hence, this algorithm uses
the first input element as pivot as that's the only one where it's
guaranteed that it then won't be moved during the partitioning step.


Partitioning Loop
-----------------
While the basic idea for this loop is the same as for the other and
the code is actually simpler, the interactions of the different parts
are more complicated.

At the beginning of the loop, l points either to
the pivot or to the last element which was examined. Thus. the loop
starts with incrementing l. If the element at the new position is >
than the pivot, an inner loop scans leftward from r for an element
that's <= the pivot. No collision check is necessary for this loop
because it's guaranteed that such an element will be found at position
l - 1. After the inner loop, if r > l, the elements at l and r are
swapped and the outer loop continues. As minor optimization for the
case that another swap will be necessary in future, r is decremented
as it's already know that the element at r is > than the pivot and
thus, can't be used for a future swap operation.

If r > l is false, the conditon of the outer loop, l < r, will
necessaribly false as well and hence, the outer loop terminates,
too. For this case, r == l - 1 will be true because nums[l] > pivot
was true. r thus points to the right-most element of the left subfield
and l to the left-most element if the right subfield. If r > ol, that
is, the left-most subfield has at least two elements, the pivot at ol
and the element at r are swapped and the algorithm is recursivley
applied to ol .. r - 1. Afterwards, if l < or, the right-most subfield
has at least two elements, it'll be applied to l .. or.

If the outer loop terminates because of l == r, this can have happened
because

    1) ++l hit r but nums[l] <= pivot
    2) --r after a swap hit l, nums[l] <= pivot because of the swap

In both cases, swapping nums[r] and the pivot, followed by running qs
on ol .. r - 1 (if not empty) will work. As nums[l] == pivot is now
true, l is incremented before running qs on l .. or if l < or.

